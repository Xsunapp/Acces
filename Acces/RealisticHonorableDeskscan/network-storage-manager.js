// Ø£Ø¯Ø§Ø© Ø¥Ø¯Ø§Ø±Ø© ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨Ù„ÙˆÙƒØªØ´ÙŠÙ† - Persistent Storage Manager
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';
import { ProfessionalBlockchainStorage } from './leveldb-storage.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class NetworkStorageManager {
  constructor(dataDir = './blockchain-data') {
    this.dataDir = dataDir;
    this.blocksFile = path.join(dataDir, 'blocks.json');
    this.stateFile = path.join(dataDir, 'state.json');
    this.mempoolFile = path.join(dataDir, 'mempool.json');
    this.backupDir = path.join(dataDir, 'backups');

    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ
    this.professionalStorage = new ProfessionalBlockchainStorage();
    this.useProfessionalStorage = true;

    this.initializeStorage();
  }

  // Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„ØªØ®Ø²ÙŠÙ†
  initializeStorage() {
    try {
      if (!fs.existsSync(this.dataDir)) {
        fs.mkdirSync(this.dataDir, { recursive: true });
        console.log(`ğŸ“ Created blockchain data directory: ${this.dataDir}`);
      }

      if (!fs.existsSync(this.backupDir)) {
        fs.mkdirSync(this.backupDir, { recursive: true });
        console.log(`ğŸ“ Created backup directory: ${this.backupDir}`);
      }

      // Advanced storage system active
    } catch (error) {
      console.error('âŒ Error initializing storage:', error);
    }
  }

  // Ø­ÙØ¸ Ù…Ø¹ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
  saveWithBackup(filename, data) {
    try {
      const fullPath = path.join(this.dataDir, filename);

      // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ù Ù…ÙˆØ¬ÙˆØ¯
      if (fs.existsSync(fullPath)) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupPath = path.join(this.backupDir, `${filename}.backup.${timestamp}`);
        fs.copyFileSync(fullPath, backupPath);
      }

      // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      fs.writeFileSync(fullPath, JSON.stringify(data, null, 2));

      return true;
    } catch (error) {
      console.error(`âŒ Error saving ${filename}:`, error);
      return false;
    }
  }

  // ØªØ­Ù…ÙŠÙ„ Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
  loadWithRecovery(filename) {
    try {
      const fullPath = path.join(this.dataDir, filename);

      if (!fs.existsSync(fullPath)) {
        console.log(`ğŸ“‹ File ${filename} not found, starting fresh`);
        return null;
      }

      const data = JSON.parse(fs.readFileSync(fullPath, 'utf8'));

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø³Ù„Ø§Ù…Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      if (this.validateData(filename, data)) {
        return data;
      } else {
        console.warn(`âš ï¸ Data corruption detected in ${filename}, attempting recovery`);
        return this.attemptRecovery(filename);
      }

    } catch (error) {
      console.error(`âŒ Error loading ${filename}:`, error);
      return this.attemptRecovery(filename);
    }
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø³Ù„Ø§Ù…Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  validateData(filename, data) {
    try {
      if (filename.includes('blocks')) {
        return data.blocks && Array.isArray(data.blocks) && data.metadata;
      } else if (filename.includes('state')) {
        return data.balances && data.metadata;
      } else if (filename.includes('mempool')) {
        return data.transactions && Array.isArray(data.transactions);
      }
      return true;
    } catch (error) {
      return false;
    }
  }

  // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ù…Ù† Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
  attemptRecovery(filename) {
    try {
      const backupFiles = fs.readdirSync(this.backupDir)
        .filter(file => file.startsWith(filename))
        .sort()
        .reverse(); // Ø£Ø­Ø¯Ø« Ù†Ø³Ø®Ø© Ø£ÙˆÙ„Ø§Ù‹

      for (const backupFile of backupFiles) {
        try {
          const backupPath = path.join(this.backupDir, backupFile);
          const data = JSON.parse(fs.readFileSync(backupPath, 'utf8'));

          if (this.validateData(filename, data)) {
            console.log(`ğŸ”„ Recovered ${filename} from backup: ${backupFile}`);
            return data;
          }
        } catch (error) {
          console.warn(`âš ï¸ Backup ${backupFile} is also corrupted`);
        }
      }

      console.error(`âŒ No valid backup found for ${filename}`);
      return null;

    } catch (error) {
      console.error(`âŒ Error during recovery attempt:`, error);
      return null;
    }
  }

  // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
  cleanupOldBackups(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 Ø£ÙŠØ§Ù…
    try {
      const backupFiles = fs.readdirSync(this.backupDir);
      const now = Date.now();

      let cleaned = 0;

      for (const file of backupFiles) {
        const filePath = path.join(this.backupDir, file);
        const stats = fs.statSync(filePath);

        if (now - stats.mtime.getTime() > maxAge) {
          fs.unlinkSync(filePath);
          cleaned++;
        }
      }

      if (cleaned > 0) {
        console.log(`ğŸ§¹ Cleaned up ${cleaned} old backup files`);
      }

    } catch (error) {
      console.error('âŒ Error cleaning up backups:', error);
    }
  }

  // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
  getStorageStats() {
    try {
      // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª JSON Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ©
      const legacyStats = {};

      ['blocks.json', 'state.json', 'mempool.json'].forEach(filename => {
        const filePath = path.join(this.dataDir, filename);
        if (fs.existsSync(filePath)) {
          const fileStats = fs.statSync(filePath);
          legacyStats[filename] = {
            size: fileStats.size,
            lastModified: fileStats.mtime,
            exists: true
          };
        } else {
          legacyStats[filename] = { exists: false };
        }
      });

      // Ø­Ø¬Ù… Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
      const backupFiles = fs.readdirSync(this.backupDir);
      const totalBackupSize = backupFiles.reduce((total, file) => {
        const filePath = path.join(this.backupDir, file);
        return total + fs.statSync(filePath).size;
      }, 0);

      legacyStats.backups = {
        count: backupFiles.length,
        totalSize: totalBackupSize
      };

      // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ
      const professionalStats = this.professionalStorage.getAdvancedStats();

      return {
        legacy_json_storage: legacyStats,
        professional_leveldb_storage: professionalStats,
        storage_comparison: {
          primary_storage: this.useProfessionalStorage ? 'LevelDB-style' : 'JSON files',
          performance_mode: this.useProfessionalStorage ? 'High Performance' : 'Basic',
          scalability: this.useProfessionalStorage ? 'Enterprise Grade' : 'Development',
          data_integrity: this.useProfessionalStorage ? 'WAL + Compaction' : 'File backups'
        }
      };

    } catch (error) {
      console.error('âŒ Error getting storage stats:', error);
      return {};
    }
  }

  // Ø­ÙØ¸ block Ø¨Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
  async saveProfessionalBlock(block) {
    if (this.useProfessionalStorage) {
      return await this.professionalStorage.saveBlock(block);
    }
    return false;
  }

  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ù„ÙˆÙƒØªØ´ÙŠÙ† Ø¨Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
  async loadProfessionalBlockchain() {
    if (this.useProfessionalStorage) {
      return await this.professionalStorage.loadBlockchain();
    }
    return { blocks: [], accounts: {}, transactions: [] };
  }

  // Ø¥ØºÙ„Ø§Ù‚ Ø¢Ù…Ù† Ù„Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ
  async closeProfessionalStorage() {
    if (this.useProfessionalStorage) {
      await this.professionalStorage.close();
    }
  }

  // ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  exportData(outputPath) {
    try {
      const exportData = {
        timestamp: Date.now(),
        version: '1.0',
        blockchain: this.loadWithRecovery('blocks.json'),
        state: this.loadWithRecovery('state.json'),
        mempool: this.loadWithRecovery('mempool.json')
      };

      fs.writeFileSync(outputPath, JSON.stringify(exportData, null, 2));
      console.log(`ğŸ“¤ Blockchain data exported to: ${outputPath}`);

      return true;
    } catch (error) {
      console.error('âŒ Error exporting data:', error);
      return false;
    }
  }
}

export default NetworkStorageManager;