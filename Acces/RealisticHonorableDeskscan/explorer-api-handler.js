// معالج API لمستكشف البلوك تشين Access
import { pool } from './db.js';
import { getNetworkNode } from './network-api.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function handleExplorerAPI(req, res, pathname, method) {
    // تفعيل CORS للمستكشف
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return true;
    }

    try {
        // API متوافق مع Etherscan
        if (pathname.startsWith('/api') && req.url.includes('module=')) {
            return await handleEtherscanAPI(req, res);
        }

        // APIs مخصصة للمستكشف
        if (pathname === '/api/explorer/stats' && method === 'GET') {
            return await handleNetworkStats(req, res);
        }

        if (pathname === '/api/explorer/latest-transactions' && method === 'GET') {
            return await handleLatestTransactions(req, res);
        }

        if (pathname === '/api/explorer/latest-blocks' && method === 'GET') {
            return await handleLatestBlocks(req, res);
        }

        if (pathname.startsWith('/api/explorer/transaction/') && method === 'GET') {
            const txHash = pathname.split('/')[4];
            return await handleTransactionDetails(req, res, txHash);
        }

        if (pathname.startsWith('/api/explorer/address/') && method === 'GET') {
            const address = pathname.split('/')[4];
            return await handleAddressDetails(req, res, address);
        }

        if (pathname.startsWith('/api/explorer/block/') && method === 'GET') {
            const blockId = pathname.split('/')[4];
            return await handleBlockDetails(req, res, blockId);
        }

        if (pathname === '/api/explorer/search' && method === 'GET') {
            return await handleSearch(req, res);
        }

        if (pathname === '/api/explorer/top-accounts' && method === 'GET') {
            return await handleTopAccounts(req, res);
        }

        return false;

    } catch (error) {
        console.error('Explorer API error:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: 'Internal server error'
        }));
        return true;
    }
}

// معالج API متوافق مع Etherscan
async function handleEtherscanAPI(req, res) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const params = Object.fromEntries(url.searchParams);

    try {
        let result;

        switch (params.module) {
            case 'account':
                result = await handleAccountModule(params);
                break;
            case 'transaction':
                result = await handleTransactionModule(params);
                break;
            case 'block':
                result = await handleBlockModule(params);
                break;
            case 'stats':
                result = await handleStatsModule(params);
                break;
            case 'proxy':
                result = await handleProxyModule(params);
                break;
            default:
                throw new Error('Invalid module');
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            status: '1',
            message: 'OK',
            result: result
        }));

    } catch (error) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            status: '0',
            message: error.message,
            result: null
        }));
    }

    return true;
}

// معالج وحدة الحساب
async function handleAccountModule(params) {
    const { action, address, startblock, endblock, sort } = params;
    const networkNode = getNetworkNode();

    switch (action) {
        case 'balance':
            if (networkNode) {
                const balance = networkNode.network.getBalance(address);
                return Math.floor(balance * 1e18).toString();
            }
            return '0';

        case 'balancemulti':
            if (networkNode) {
                const addresses = address.split(',');
                const balances = addresses.map(addr => ({
                    account: addr,
                    balance: Math.floor(networkNode.network.getBalance(addr) * 1e18).toString()
                }));
                return balances;
            }
            return address.split(',').map(addr => ({ account: addr, balance: '0' }));

        case 'txlist':
            return await getTransactionsByAddress(address, startblock, endblock, sort);

        default:
            throw new Error('Invalid action for account module');
    }
}

// معالج وحدة المعاملة
async function handleTransactionModule(params) {
    const { action, txhash } = params;
    const networkNode = getNetworkNode();

    switch (action) {
        case 'gettxreceiptstatus':
            if (networkNode) {
                const tx = networkNode.network.getTransactionByHash(txhash);
                return { status: tx ? '1' : '0' };
            }
            const dbResult = await pool.query('SELECT tx_hash FROM transactions WHERE tx_hash = $1', [txhash]);
            return { status: dbResult.rows.length > 0 ? '1' : '0' };

        default:
            throw new Error('Invalid action for transaction module');
    }
}

// معالج وحدة البلوك
async function handleBlockModule(params) {
    const { action, blockno } = params;
    const networkNode = getNetworkNode();

    switch (action) {
        case 'getblockreward':
            const reward = networkNode ? networkNode.network.processingReward : 0.25;
            return {
                blockNumber: blockno,
                timeStamp: Math.floor(Date.now() / 1000).toString(),
                blockMiner: 'access-system-miner',
                blockReward: Math.floor(reward * 1e18).toString()
            };

        default:
            throw new Error('Invalid action for block module');
    }
}

// معالج وحدة الإحصائيات
async function handleStatsModule(params) {
    const { action } = params;
    const networkNode = getNetworkNode();

    switch (action) {
        case 'tokensupply':
            if (networkNode) {
                const supply = await networkNode.network.calculateCirculatingSupply();
                return Math.floor(supply * 1e18).toString();
            }
            return '0';

        case 'chainsize':
            if (networkNode) {
                return {
                    blockNumber: networkNode.network.chain.length - 1,
                    chainSize: JSON.stringify(networkNode.network.chain).length,
                    clientType: 'AccessNode'
                };
            }
            const blockCount = await pool.query('SELECT MAX(block_index) as max_block FROM transactions');
            return {
                blockNumber: blockCount.rows[0]?.max_block || 0,
                chainSize: 0,
                clientType: 'AccessNode'
            };

        default:
            throw new Error('Invalid action for stats module');
    }
}

// معالج وحدة Proxy (متوافق مع Etherscan API)
async function handleProxyModule(params) {
    const { action, tag, address, txhash, hex, boolean } = params;
    const networkNode = getNetworkNode();

    if (!networkNode) {
        throw new Error('Network not initialized');
    }

    switch (action) {
        case 'access_blockNumber':
        case 'eth_blockNumber':
            const latestBlock = networkNode.network.getLatestBlock();
            return '0x' + (latestBlock?.index || 0).toString(16);

        case 'access_getBlockByNumber':
        case 'eth_getBlockByNumber':
            const blockNum = parseInt(tag, 16);
            const block = networkNode.network.getBlockByIndex(blockNum);
            if (!block) {
                throw new Error('Block not found');
            }
            
            const includeFullTxs = boolean === 'true';
            return {
                number: '0x' + block.index.toString(16),
                hash: block.hash,
                timestamp: '0x' + Math.floor(block.timestamp / 1000).toString(16),
                transactions: includeFullTxs ? (block.transactions || []) : (block.transactions || []).map(tx => tx.hash),
                gasUsed: '0x' + ((block.transactions?.length || 0) * 21000).toString(16),
                gasLimit: '0x' + (30000000).toString(16),
                miner: '0x0000000000000000000000000000000000000000',
                difficulty: '0x' + (block.difficulty || 1).toString(16),
                size: '0x' + JSON.stringify(block).length.toString(16)
            };

        case 'access_getTransactionByHash':
        case 'eth_getTransactionByHash':
            const tx = networkNode.network.getTransactionByHash(txhash);
            if (!tx) {
                // البحث في قاعدة البيانات
                const dbTx = await pool.query('SELECT * FROM transactions WHERE tx_hash = $1', [txhash]);
                if (dbTx.rows.length === 0) {
                    throw new Error('Transaction not found');
                }
                const row = dbTx.rows[0];
                return {
                    hash: row.tx_hash,
                    from: row.from_address,
                    to: row.to_address,
                    value: '0x' + Math.floor(parseFloat(row.amount) * 1e18).toString(16),
                    gas: '0x5208',
                    gasPrice: '0x' + Math.floor(0.00002 * 1e18).toString(16),
                    nonce: '0x0',
                    blockNumber: '0x' + (row.block_index || 0).toString(16),
                    blockHash: row.block_hash,
                    transactionIndex: '0x0',
                    input: '0x',
                    signature: row.signature || null,
                    r: row.signature ? ('0x' + row.signature.substring(0, 64)) : null,
                    s: row.signature ? ('0x' + row.signature.substring(64, 128)) : null,
                    v: row.signature ? '0x1b' : null
                };
            }
            return {
                hash: tx.hash,
                from: tx.fromAddress || tx.from,
                to: tx.toAddress || tx.to,
                value: '0x' + Math.floor((tx.amount || tx.value || 0) * 1e18).toString(16),
                gas: '0x5208',
                gasPrice: '0x' + Math.floor((tx.gasPrice || 0.00002) * 1e18).toString(16),
                nonce: '0x' + (tx.nonce || 0).toString(16),
                blockNumber: '0x' + (tx.blockIndex || 0).toString(16),
                blockHash: tx.blockHash || '',
                transactionIndex: '0x0',
                input: '0x',
                signature: tx.signature || null,
                r: tx.signature ? ('0x' + tx.signature.substring(0, 64)) : null,
                s: tx.signature ? ('0x' + tx.signature.substring(64, 128)) : null,
                v: tx.signature ? '0x1b' : null
            };

        case 'access_getTransactionCount':
        case 'eth_getTransactionCount':
            const txs = await getTransactionsByAddress(address);
            return '0x' + txs.length.toString(16);

        case 'access_sendRawTransaction':
        case 'eth_sendRawTransaction':
            throw new Error('This endpoint requires POST method with signed transaction data');

        case 'access_gasPrice':
        case 'eth_gasPrice':
            const gasPrice = networkNode.network.getGasPrice();
            return '0x' + Math.floor(gasPrice * 1e18).toString(16);

        default:
            throw new Error('Invalid action for proxy module: ' + action);
    }
}

// الحصول على إحصائيات الشبكة
async function handleNetworkStats(req, res) {
    try {
        const networkNode = getNetworkNode();

        // Get real transaction count from database only
        const txCount = await pool.query('SELECT COUNT(*) as count FROM transactions');
        const blockCount = await pool.query('SELECT MAX(block_index) as max_block FROM transactions');
        const realTotalTransactions = parseInt(txCount.rows[0]?.count || 0);

        // If network node is available, use it for other data
        if (networkNode) {
            const networkInfo = networkNode.network.getNetworkInfo();
            const stats = networkNode.getStats();
            const totalSupply = await networkNode.network.calculateCirculatingSupply();
            const latestBlock = networkNode.network.getLatestBlock();

            const result = {
                totalTransactions: realTotalTransactions,
                latestBlock: latestBlock?.index || 0,
                blockTime: 1,
                totalSupply: totalSupply,
                networkHashRate: stats?.hashRate || 0,
                difficulty: networkNode.network.difficulty || 1,
                gasPrice: networkNode.network.getGasPrice(),
                tps: stats?.transactionsPerSecond || 0
            };

            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ success: true, data: result }));
            return true;
        }

        // Fallback: Get stats from database only
        const result = {
            totalTransactions: realTotalTransactions,
            latestBlock: parseInt(blockCount.rows[0]?.max_block || 0),
            blockTime: 1,
            totalSupply: 0,
            networkHashRate: 0,
            difficulty: 1,
            gasPrice: 21000,
            tps: 0
        };

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true, data: result }));

    } catch (error) {
        console.error('Error getting network stats:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: false, error: error.message }));
    }

    return true;
}

// الحصول على آخر المعاملات
async function handleLatestTransactions(req, res) {
    try {
        const url = new URL(req.url, `http://${req.headers.host}`);
        const limit = parseInt(url.searchParams.get('limit')) || 10;

        // الحصول من قاعدة البيانات
        const result = await pool.query(`
            SELECT tx_hash, from_address, to_address, amount, timestamp, block_index, block_hash
            FROM transactions 
            ORDER BY timestamp DESC
            LIMIT $1
        `, [limit]);

        const networkNode = getNetworkNode();
        let transactions = result.rows.map(row => ({
            hash: row.tx_hash,
            from: row.from_address,
            to: row.to_address,
            value: row.amount,
            timestamp: Math.floor(row.timestamp / 1000),
            blockNumber: row.block_index,
            blockHash: row.block_hash,
            gasPrice: networkNode ? networkNode.network.getGasPrice() : 0.000000001,
            gasUsed: 21000,
            status: 'success'
        }));

        // إذا لم توجد معاملات في قاعدة البيانات، احصل عليها من البلوك تشين
        if (transactions.length === 0 && networkNode) {
            const allTransactions = networkNode.network.getAllTransactions();
            transactions = allTransactions.slice(-limit).reverse().map(tx => ({
                hash: tx.hash || tx.txId,
                from: tx.fromAddress || tx.from,
                to: tx.toAddress || tx.to,
                value: tx.amount || tx.value,
                timestamp: Math.floor((tx.timestamp || Date.now()) / 1000),
                blockNumber: tx.blockIndex || 0,
                blockHash: tx.blockHash || '',
                gasPrice: tx.gasPrice || networkNode.network.getGasPrice(),
                gasUsed: tx.gasUsed || 21000,
                status: 'success'
            }));
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: transactions
        }));

    } catch (error) {
        console.error('Error getting latest transactions:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// الحصول على آخر البلوكات
async function handleLatestBlocks(req, res) {
    try {
        const url = new URL(req.url, `http://${req.headers.host}`);
        const limit = parseInt(url.searchParams.get('limit')) || 10;

        const networkNode = getNetworkNode();
        const blocks = [];

        if (networkNode) {
            const latestBlockNumber = networkNode.network.chain.length - 1;

            for (let i = 0; i < limit && (latestBlockNumber - i) >= 0; i++) {
                const blockIndex = latestBlockNumber - i;
                const block = networkNode.network.getBlockByIndex(blockIndex);

                if (block) {
                    // حساب عدد المعاملات الفعلية بدقة
                    let txCount = 0;
                    if (block.transactions && Array.isArray(block.transactions)) {
                      // استثناء معاملة الـ reward من العدد
                      txCount = block.transactions.filter(tx => 
                        tx.fromAddress !== null && 
                        tx.toAddress !== '0x0000000000000000000000000000000000000000' &&
                        tx.toAddress !== '0x0000000000000000000000000000000000000001'
                      ).length;
                    }

                    blocks.push({
                        number: block.index,
                        hash: block.hash,
                        timestamp: Math.floor(block.timestamp / 1000),
                        transactions: txCount,
                        transactionCount: txCount,
                        miner: 'Block Validator',
                        size: JSON.stringify(block).length,
                        gasUsed: (txCount) * 21000,
                        gasLimit: 30000000,
                        difficulty: block.difficulty || 1,
                        reward: networkNode.network.processingReward
                    });
                }
            }
        } else {
            // Fallback: Get blocks from database by grouping transactions
            const result = await pool.query(`
                SELECT DISTINCT block_index, block_hash, timestamp
                FROM transactions
                WHERE block_index IS NOT NULL
                ORDER BY block_index DESC
                LIMIT $1
            `, [limit]);

            for (const row of result.rows) {
                // Get transaction count for this block
                const txCount = await pool.query(
                    'SELECT COUNT(*) as count FROM transactions WHERE block_index = $1',
                    [row.block_index]
                );

                blocks.push({
                    number: row.block_index,
                    index: row.block_index,
                    hash: row.block_hash || `0x${row.block_index}`,
                    timestamp: Math.floor(new Date(row.timestamp).getTime() / 1000),
                    transactions: parseInt(txCount.rows[0]?.count || 0),
                    transactionCount: parseInt(txCount.rows[0]?.count || 0),
                    miner: 'Block Validator',
                    validator: 'Block Validator',
                    size: 1024,
                    gasUsed: parseInt(txCount.rows[0]?.count || 0) * 21000,
                    gasLimit: 30000000,
                    difficulty: 1,
                    reward: 0.25
                });
            }
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: blocks
        }));

    } catch (error) {
        console.error('Error getting latest blocks:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// تفاصيل المعاملة
async function handleTransactionDetails(req, res, txHash) {
    try {
        const networkNode = getNetworkNode();
        let transaction = null;

        // البحث في البلوك تشين أولاً
        if (networkNode) {
            transaction = networkNode.network.getTransactionByHash(txHash);
        }

        // البحث في قاعدة البيانات
        if (!transaction) {
            const result = await pool.query(
                'SELECT * FROM transactions WHERE tx_hash = $1',
                [txHash]
            );

            if (result.rows.length > 0) {
                const row = result.rows[0];
                transaction = {
                    hash: row.tx_hash,
                    from: row.from_address,
                    to: row.to_address,
                    value: row.amount,
                    timestamp: Math.floor(row.timestamp / 1000),
                    blockNumber: row.block_index,
                    blockHash: row.block_hash,
                    gasPrice: networkNode ? networkNode.network.getGasPrice() : 0.000000001,
                    gasUsed: 21000,
                    gasLimit: 21000,
                    nonce: 0,
                    transactionIndex: 0,
                    status: 'success'
                };
            }
        }

        if (!transaction) {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                success: false,
                error: 'Transaction not found'
            }));
            return true;
        }

        // إضافة تفاصيل إضافية
        const enhancedTransaction = {
            ...transaction,
            confirmations: networkNode ? (networkNode.network.chain.length - (transaction.blockNumber || 0)) : 1,
            input: '0x',
            logs: [],
            type: 0,
            effectiveGasPrice: transaction.gasPrice || (networkNode ? networkNode.network.getGasPrice() : 0.000000001)
        };

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: enhancedTransaction
        }));

    } catch (error) {
        console.error('Error getting transaction details:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// تفاصيل العنوان
async function handleAddressDetails(req, res, address) {
    try {
        const networkNode = getNetworkNode();
        const balance = networkNode ? networkNode.network.getBalance(address) : 0;

        // الحصول على المعاملات
        const transactions = await getTransactionsByAddress(address);

        // حساب الإحصائيات
        const totalSent = transactions
            .filter(tx => tx.from && tx.from.toLowerCase() === address.toLowerCase())
            .reduce((sum, tx) => sum + parseFloat(tx.value || 0), 0);

        const totalReceived = transactions
            .filter(tx => tx.to && tx.to.toLowerCase() === address.toLowerCase())
            .reduce((sum, tx) => sum + parseFloat(tx.value || 0), 0);

        const addressInfo = {
            address: address,
            balance: balance,
            balanceUSD: balance * 0.001,
            transactionCount: transactions.length,
            totalSent: totalSent,
            totalReceived: totalReceived,
            firstSeen: transactions.length > 0 ? Math.min(...transactions.map(tx => tx.timestamp)) : null,
            lastSeen: transactions.length > 0 ? Math.max(...transactions.map(tx => tx.timestamp)) : null,
            isContract: false,
            transactions: transactions.slice(0, 25)
        };

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: addressInfo
        }));

    } catch (error) {
        console.error('Error getting address details:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// تفاصيل البلوك
async function handleBlockDetails(req, res, blockId) {
    try {
        const networkNode = getNetworkNode();
        let block;

        if (networkNode) {
            if (blockId === 'latest') {
                block = networkNode.network.getLatestBlock();
            } else if (blockId.startsWith('0x')) {
                block = networkNode.network.getBlockByHash(blockId);
            } else {
                const index = parseInt(blockId);
                block = networkNode.network.getBlockByIndex(index);
            }
        } else {
            // Fallback: Get from database
            const blockIndex = blockId === 'latest' ? null : parseInt(blockId);
            const query = blockIndex !== null 
                ? 'SELECT DISTINCT block_index, block_hash, timestamp FROM transactions WHERE block_index = $1'
                : 'SELECT DISTINCT block_index, block_hash, timestamp FROM transactions ORDER BY block_index DESC LIMIT 1';
            const params = blockIndex !== null ? [blockIndex] : [];
            const result = await pool.query(query, params);

            if (result.rows.length > 0) {
                const row = result.rows[0];
                block = {
                    index: row.block_index,
                    hash: row.block_hash || `0x${row.block_index}`,
                    timestamp: new Date(row.timestamp).getTime(),
                    transactions: []
                };
            }
        }

        if (!block) {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                success: false,
                error: 'Block not found'
            }));
            return true;
        }

        const enhancedBlock = {
            ...block,
            size: JSON.stringify(block).length,
            gasUsed: (block.transactions?.length || 0) * 21000,
            gasLimit: 30000000,
            difficulty: block.difficulty || 1,
            totalDifficulty: (block.index + 1) * (block.difficulty || 1),
            miner: 'Block Validator',
            reward: networkNode ? networkNode.network.processingReward : 0.25,
            uncles: [],
            sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
            logsBloom: '0x' + '0'.repeat(512),
            transactionsRoot: block.hash,
            stateRoot: block.hash,
            receiptsRoot: block.hash,
            extraData: '0x',
            mixHash: '0x' + '0'.repeat(64),
            nonce: '0x' + (block.nonce?.toString(16).padStart(16, '0') || '0000000000000000')
        };

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: enhancedBlock
        }));

    } catch (error) {
        console.error('Error getting block details:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// البحث
async function handleSearch(req, res) {
    try {
        const url = new URL(req.url, `http://${req.headers.host}`);
        const query = url.searchParams.get('q')?.trim();

        if (!query) {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                success: false,
                error: 'Search query required'
            }));
            return true;
        }

        const networkNode = getNetworkNode();
        let result = null;
        let type = null;

        // فحص نوع البحث
        if (query.match(/^0x[a-fA-F0-9]{40}$/)) {
            // عنوان
            const balance = networkNode ? networkNode.network.getBalance(query) : 0;
            const transactions = await getTransactionsByAddress(query, 0, 'latest', 'desc', 10);

            result = {
                address: query,
                balance: balance,
                transactionCount: transactions.length
            };
            type = 'address';

        } else if (query.match(/^0x[a-fA-F0-9]{64}$/)) {
            // هاش معاملة
            if (networkNode) {
                const transaction = networkNode.network.getTransactionByHash(query);
                if (transaction) {
                    result = transaction;
                    type = 'transaction';
                }
            } else {
                const dbResult = await pool.query('SELECT * FROM transactions WHERE tx_hash = $1', [query]);
                if (dbResult.rows.length > 0) {
                    result = dbResult.rows[0];
                    type = 'transaction';
                }
            }

        } else if (/^\d+$/.test(query)) {
            // رقم بلوك
            const blockIndex = parseInt(query);
            if (networkNode) {
                const block = networkNode.network.getBlockByIndex(blockIndex);
                if (block) {
                    result = block;
                    type = 'block';
                }
            } else {
                const dbResult = await pool.query('SELECT DISTINCT block_index, block_hash, timestamp FROM transactions WHERE block_index = $1', [blockIndex]);
                if (dbResult.rows.length > 0) {
                    result = dbResult.rows[0];
                    type = 'block';
                }
            }

        } else if (query.startsWith('0x') && query.length === 66) {
            // هاش بلوك
            if (networkNode) {
                const block = networkNode.network.getBlockByHash(query);
                if (block) {
                    result = block;
                    type = 'block';
                }
            }
        }

        if (!result) {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                success: false,
                error: 'Not found'
            }));
            return true;
        }

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            type: type,
            data: result
        }));

    } catch (error) {
        console.error('Error in search:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}

// الحصول على معاملات العنوان
async function getTransactionsByAddress(address, startblock = 0, endblock = 'latest', sort = 'desc', limit = 1000) {
    try {
        // البحث في قاعدة البيانات أولاً
        const result = await pool.query(`
            SELECT tx_hash, from_address, to_address, amount, timestamp, block_index, block_hash
            FROM transactions 
            WHERE from_address = $1 OR to_address = $1
            ORDER BY timestamp ${sort === 'desc' ? 'DESC' : 'ASC'}
            LIMIT $2
        `, [address.toLowerCase(), limit]);

        const networkNode = getNetworkNode();
        const gasPrice = networkNode ? networkNode.network.getGasPrice() : 0.000000001;

        const transactions = result.rows.map(row => ({
            blockNumber: row.block_index?.toString() || '0',
            timeStamp: Math.floor(row.timestamp / 1000).toString(),
            hash: row.tx_hash,
            from: row.from_address,
            to: row.to_address,
            value: Math.floor((row.amount || 0) * 1e18).toString(),
            gas: '21000',
            gasPrice: Math.floor(gasPrice * 1e18).toString(),
            gasUsed: '21000',
            input: '0x',
            contractAddress: '',
            cumulativeGasUsed: '21000',
            txreceipt_status: '1',
            confirmations: networkNode ? (networkNode.network.chain.length - (row.block_index || 0)) : 1
        }));

        // إذا لم توجد معاملات في قاعدة البيانات، احصل عليها من البلوك تشين
        if (transactions.length === 0 && networkNode) {
            const allTransactions = networkNode.network.getAllTransactionsForWallet(address);
            return allTransactions.slice(0, limit).map(tx => ({
                blockNumber: tx.blockIndex?.toString() || '0',
                timeStamp: Math.floor((tx.timestamp || Date.now()) / 1000).toString(),
                hash: tx.hash || tx.txId,
                from: tx.fromAddress || tx.from,
                to: tx.toAddress || tx.to,
                value: Math.floor((tx.amount || tx.value || 0) * 1e18).toString(),
                gas: '21000',
                gasPrice: Math.floor(gasPrice * 1e18).toString(),
                gasUsed: '21000',
                input: '0x',
                contractAddress: '',
                cumulativeGasUsed: '21000',
                txreceipt_status: '1',
                confirmations: networkNode.network.chain.length - (tx.blockIndex || 0)
            }));
        }

        return transactions;

    } catch (error) {
        console.error('Error getting transactions by address:', error);
        return [];
    }
}

// الحصول على أفضل الحسابات (Top Accounts)
async function handleTopAccounts(req, res) {
    try {
        const url = new URL(req.url, `http://${req.headers.host}`);
        const limit = parseInt(url.searchParams.get('limit')) || 100;
        const page = parseInt(url.searchParams.get('page')) || 1;
        const offset = (page - 1) * limit;

        // جلب جميع الحسابات من جداول مختلفة (بدون بيانات شخصية)
        const usersQuery = await pool.query(`
            SELECT 
                wallet_address as address,
                coins as balance
            FROM users
            WHERE wallet_address IS NOT NULL AND wallet_address != ''
        `);

        const externalWalletsQuery = await pool.query(`
            SELECT 
                address,
                balance
            FROM external_wallets
            WHERE address IS NOT NULL
        `);

        // ✅ جلب حسابات web3 من مجلد ethereum-network-data/accounts/
        const web3Accounts = [];
        try {
            // استخدام __dirname للحصول على مسار المجلد الحالي
            const accountsDir = path.join(__dirname, 'ethereum-network-data', 'accounts');
            
            if (fs.existsSync(accountsDir)) {
                // قراءة جميع ملفات JSON في المجلد
                const files = fs.readdirSync(accountsDir).filter(file => file.endsWith('.json'));
                
                for (const file of files) {
                    const filePath = path.join(accountsDir, file);
                    const accountData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    
                    // الرصيد موجود كـ string في الملف (مثل: "95.48")
                    const balanceInAccess = parseFloat(accountData.balance || '0');
                    
                    web3Accounts.push({
                        address: accountData.address,
                        balance: balanceInAccess
                    });
                }
                
                console.log(`✅ Loaded ${web3Accounts.length} web3 accounts from ethereum-network-data/accounts/`);
            }
        } catch (error) {
            console.warn('⚠️ Error loading web3 accounts from ethereum-network-data/accounts/:', error.message);
        }

        // دمج جميع الحسابات من المصادر الثلاثة وإزالة التكرارات
        const accountsMap = new Map();
        
        // دمج الحسابات (web3 accounts لها الأولوية للرصيد لأنها الحالة الفعلية على blockchain)
        const allSources = [...usersQuery.rows, ...externalWalletsQuery.rows, ...web3Accounts];
        
        for (const account of allSources) {
            const normalizedAddress = account.address.toLowerCase();
            
            if (accountsMap.has(normalizedAddress)) {
                // إذا كان الحساب موجود، احتفظ بأكبر رصيد فقط
                const existing = accountsMap.get(normalizedAddress);
                accountsMap.set(normalizedAddress, {
                    address: account.address,
                    balance: Math.max(existing.balance, parseFloat(account.balance || 0))
                });
            } else {
                accountsMap.set(normalizedAddress, {
                    address: account.address,
                    balance: parseFloat(account.balance || 0)
                });
            }
        }
        
        const allAccounts = Array.from(accountsMap.values());
        console.log(`✅ Total unique accounts: ${allAccounts.length} (from ${allSources.length} total entries)`);

        // حساب إجمالي المبلغ وعدد المعاملات لكل حساب
        const accountsWithStats = await Promise.all(allAccounts.map(async (account) => {
            const txCountQuery = await pool.query(`
                SELECT COUNT(*) as count
                FROM transactions
                WHERE from_address = $1 OR to_address = $1
            `, [account.address.toLowerCase()]);

            const balance = parseFloat(account.balance || 0);
            const txCount = parseInt(txCountQuery.rows[0]?.count || 0);

            return {
                address: account.address,
                balance: balance,
                txCount: txCount
            };
        }));

        // ترتيب حسب الرصيد (من الأعلى للأقل)
        accountsWithStats.sort((a, b) => b.balance - a.balance);

        // حساب إجمالي العرض
        const totalSupply = accountsWithStats.reduce((sum, acc) => sum + acc.balance, 0);

        // تطبيق الصفحات
        const paginatedAccounts = accountsWithStats.slice(offset, offset + limit);

        // حساب النسبة المئوية لكل حساب
        // ⚠️ خصوصية المستخدمين: لا نرسل أي بيانات شخصية (name, email) في API للمطورين
        const accountsWithPercentage = paginatedAccounts.map((account, index) => ({
            rank: offset + index + 1,
            address: account.address,
            balance: account.balance.toFixed(8),
            balanceRaw: account.balance,
            percentage: totalSupply > 0 ? ((account.balance / totalSupply) * 100).toFixed(8) : '0',
            txCount: account.txCount
            // ❌ nameTag تم إزالته لحماية خصوصية المستخدمين - فقط address و balance
        }));

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: true,
            data: {
                accounts: accountsWithPercentage,
                total: accountsWithStats.length,
                totalSupply: totalSupply.toFixed(8),
                page: page,
                limit: limit,
                totalPages: Math.ceil(accountsWithStats.length / limit)
            }
        }));

    } catch (error) {
        console.error('Error getting top accounts:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            success: false,
            error: error.message
        }));
    }

    return true;
}